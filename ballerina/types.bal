// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/constraint;
import ballerina/data.jsondata;
import ballerina/http;

# The week of available time rule
public type InlineResponse2006SegmentsRecurrence record {
    # Thursday
    ScheduleravailabilitySegmentsRecurrenceSun[] thu?;
    # Tuesday
    ScheduleravailabilitySegmentsRecurrenceSun[] tue?;
    # Wednesday
    ScheduleravailabilitySegmentsRecurrenceSun[] wed?;
    # Saturday
    ScheduleravailabilitySegmentsRecurrenceSun[] sat?;
    # Friday 
    ScheduleravailabilitySegmentsRecurrenceSun[] fri?;
    # Sundays
    ScheduleravailabilitySegmentsRecurrenceSun[] sun?;
    # Monday
    ScheduleravailabilitySegmentsRecurrenceSun[] mon?;
};

# The availability schedule set by the user
public type SchedulerAvailabilityBody record {
    # the owner's ID
    string owner?;
    # The default availability schedule in use
    boolean default?;
    # The name of this availability schedule
    @constraint:String {minLength: 1}
    string name;
    # The unique ID of availability
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    ScheduleravailabilitySegmentsRecurrence segmentsRecurrence?;
    # The timezone for which this availability schedule originates
    @jsondata:Name {value: "time_zone"}
    string timeZone;
    # The date on which the rule needs to be applied outside of the availability rule
    ScheduleravailabilitySegments[] segments?;
};

# The creator of the schedule. The field is read-only
public type InlineResponse2011Creator record {
    # This field indicates if you created the schedule. The field is read-only
    boolean self?;
    # This field indicates the creator of the display name
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # This field indicates the creator's email address
    string email?;
};

public type InlineResponse2005AvailabilityRules record {
    # This field indicates the use of custom availability instead of the rule
    @jsondata:Name {value: "use_custom"}
    boolean useCustom?;
    # The ID of this availability rule. 
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesscheduleIdSegmentsRecurrence1 segmentsRecurrence?;
    # The timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The owner of this availability rule. 
    string email?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
};

public type SchedulesSingleUseLinkBody record {
    # The unique identifier of a schedule
    @jsondata:Name {value: "schedule_id"}
    string scheduleId;
};

public type SchedulerschedulesCustomFields record {
    # The invitee's option(s) for `single_select` or `multi_select` type of responses
    @jsondata:Name {value: "answer_choices"}
    SchedulerschedulesCustomFieldsAnswerchoicesItemsString[] answerChoices?;
    # The ID of this question
    @jsondata:Name {value: "custom_field_id"}
    string customFieldId?;
    # The type of response that the invitee provides to the custom question. It can be one or multiple lines of text, a phone number, or single- or multiple-select.[`string text phone_number single_select multi_select`]
    "text"|"string"|"phone_number"|"choices_one"|"choices_many"|"select" format;
    # The custom question the host created for the event type
    string name;
    # This field is true if the custom question allows invitees to record a written response in addition to single-select or multiple-select type of responses. This field is false if the custom question does not allow invitees to record a written response
    @jsondata:Name {value: "include_other"}
    boolean includeOther;
    # The position of this question
    decimal position;
    # This field is true if the question the host creates is ON and visible on the event booking page. This field is false if it's OFF and invisible on the event booking page
    boolean enabled;
    # This field is true if a response to the question created by the host is required for invitees to book the event type. This field is false if a response to the question created by the host is not required for invitees to book the event type
    boolean required;
};

# Represents the Queries record for the operation: get_scheduled_events
public type GetScheduledEventsQueries record {
    # This field indicates whether the admin handles certain users. It's only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

public type SchedulesscheduleIdBody record {
    # The method of `addOn`, such as Zoom meeting, Zoom phone, and offline
    @jsondata:Name {value: "add_on_type"}
    "zoomMeeting"|"zoomPhone"|"offline" addOnType?;
    # The schedule's end date
    @jsondata:Name {value: "end_date"}
    string endDate?;
    # This field sets the frequency of available time slots for invitees
    @jsondata:Name {value: "start_time_increment"}
    decimal startTimeIncrement?;
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # The hexadecimal color value of the event type's scheduling page
    string color?;
    # The custom question
    @jsondata:Name {value: "custom_fields"}
    SchedulerschedulesscheduleIdCustomFields[] customFields?;
    # The schedule's description
    @constraint:String {maxLength: 8192}
    string description?;
    # This field indicates if the schedule is active
    boolean active?;
    # This field sets the maximum events allowed per day
    @jsondata:Name {value: "booking_limit"}
    decimal bookingLimit?;
    # This field indicates if the event type is hidden on the owner's main scheduling page
    boolean secret?;
    # the timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The availability time rule
    @jsondata:Name {value: "availability_rules"}
    SchedulerschedulesscheduleIdAvailabilityRules[] availabilityRules?;
    # The maximum invitees per event
    @constraint:Number {minValue: 1, maxValue: 200}
    decimal capacity?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
    # The duration of meeting in minutes, range: [1, 1440]
    @constraint:Number {minValue: 15, maxValue: 1440}
    decimal duration?;
    # The minimum time before a schedule starts that attendees can book
    @constraint:Number {minValue: 0, maxValue: 14340}
    decimal cushion?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # The extra time before or after booked schedule
    SchedulerschedulesscheduleIdBuffer buffer?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesscheduleIdSegmentsRecurrence1 segmentsRecurrence?;
    # The event portion of the event's URL that identifies a specific web page
    @constraint:String {maxLength: 256, minLength: 3}
    string slug?;
    # The schedule time range. Unlimited means forever and fixed means using `startDate` and `endDate`
    @jsondata:Name {value: "interval_type"}
    "unlimited"|"fixed" intervalType?;
    # This field indicates the use of the availability rule
    @jsondata:Name {value: "availability_override"}
    boolean availabilityOverride?;
    # The schedule's start date
    @jsondata:Name {value: "start_date"}
    string startDate?;
    # The status of schedule, confirmed or cancelled
    "confirmed"|"cancelled" status?;
};

public type InlineResponse2003Items record {
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # The attendees of the event
    InlineResponse2003Attendees[] attendees?;
    # The meeting notes of the event
    @jsondata:Name {value: "meeting_notes"}
    string meetingNotes?;
    # The event's description
    @constraint:String {maxLength: 8192}
    string description?;
    # The scheduled event end date time
    @jsondata:Name {value: "end_date_time"}
    string endDateTime?;
    # The unique identifier of event
    @jsondata:Name {value: "event_id"}
    string eventId?;
    # This field indicates the type is default(scheduled) or pending event
    @jsondata:Name {value: "event_type"}
    "default"|"pending" eventType?;
    # The information to track the source of invitee. This occurs when you add UTM parameters in schedule links
    @jsondata:Name {value: "tracking_params"}
    InlineResponse2003TrackingParams[] trackingParams?;
    # The guest's collection
    string[] guests?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # The scheduled event start date time
    @jsondata:Name {value: "start_date_time"}
    string startDateTime?;
    # The unique identifier of schedule
    @jsondata:Name {value: "schedule_id"}
    string scheduleId?;
    # The moment the event was updated
    string updated?;
    # The meeting details for when users have scheduled appointments
    @jsondata:Name {value: "external_location"}
    record {string kind?; string meeting_id?; string personal_meeting_id?; string meeting_passcode?; string meeting_description?; string meeting_join_url?;} externalLocation?;
    # The status of event: confirmed or cancelled
    "confirmed"|"cancelled" status?;
};

public type InlineResponse2011CustomFields record {
    # The invitee's option(s) for single_select or multi_select type of responses
    @jsondata:Name {value: "answer_choices"}
    InlineResponse2011CustomFieldsAnswerchoicesItemsString[] answerChoices?;
    # The ID of this question
    @jsondata:Name {value: "custom_field_id"}
    string customFieldId?;
    # The type of response that the invitee provides to the custom question. It can be one or multiple lines of text, a phone number, or single- or multiple-select.[`string text phone_number single_select multi_select`]
    "text"|"string"|"phone_number"|"choices_one"|"choices_many"|"select" format;
    # The custom question the host created for the event type
    string name;
    # This field is true if the custom question allows invitees to record a written response in addition to single-select or multiple-select type of responses. This field is false if the custom question does not allow invitees to record a written response
    @jsondata:Name {value: "include_other"}
    boolean includeOther;
    # The position of this question
    decimal position;
    # This field is true if the question the host creates is ON and visible on the event booking page. This field is false if it's OFF and invisible on the event booking page
    boolean enabled;
    # This field is true if a response to the question created by the host is required for invitees to book the event type. This field is false if a response to the question created by the host is not required for invitees to book the event type
    boolean required;
};

public type InlineResponse2006AvailabilityRules record {
    # This field indicates the use of custom availability instead of the rule
    @jsondata:Name {value: "use_custom"}
    boolean useCustom?;
    # The ID of this availability rule. 
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    InlineResponse2006SegmentsRecurrence segmentsRecurrence?;
    # The timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The owner of this availability rule. 
    string email?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
};

# Represents the Queries record for the operation: get_schedule
public type GetScheduleQueries record {
    # This field indicates that admins handle certain users. This setting is only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

public type InlineResponse2011CustomFieldsAnswerchoicesItemsString string;

# Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.
@display {label: "Connection Config"}
public type ConnectionConfig record {|
    # Configurations related to client authentication
    http:BearerTokenConfig|http:OAuth2RefreshTokenGrantConfig auth;
    # The HTTP version understood by the client
    http:HttpVersion httpVersion = http:HTTP_2_0;
    # Configurations related to HTTP/1.x protocol
    http:ClientHttp1Settings http1Settings = {};
    # Configurations related to HTTP/2 protocol
    http:ClientHttp2Settings http2Settings = {};
    # The maximum time to wait (in seconds) for a response before closing the connection
    decimal timeout = 30;
    # The choice of setting `forwarded`/`x-forwarded` header
    string forwarded = "disable";
    # Configurations associated with Redirection
    http:FollowRedirects followRedirects?;
    # Configurations associated with request pooling
    http:PoolConfiguration poolConfig?;
    # HTTP caching related configurations
    http:CacheConfig cache = {};
    # Specifies the way of handling compression (`accept-encoding`) header
    http:Compression compression = http:COMPRESSION_AUTO;
    # Configurations associated with the behaviour of the Circuit Breaker
    http:CircuitBreakerConfig circuitBreaker?;
    # Configurations associated with retrying
    http:RetryConfig retryConfig?;
    # Configurations associated with cookies
    http:CookieConfig cookieConfig?;
    # Configurations associated with inbound response size limits
    http:ResponseLimitConfigs responseLimits = {};
    # SSL/TLS-related options
    http:ClientSecureSocket secureSocket?;
    # Proxy server related options
    http:ProxyConfig proxy?;
    # Provides settings related to client socket configuration
    http:ClientSocketConfig socketConfig = {};
    # Enables the inbound payload validation functionality which provided by the constraint package. Enabled by default
    boolean validation = true;
    # Enables relaxed data binding on the client side. When enabled, `nil` values are treated as optional, 
    # and absent fields are handled as `nilable` types. Enabled by default.
    boolean laxDataBinding = true;
|};

public type InlineResponse2011AvailabilityRules record {
    # This field indicates the use of custom availability instead of the rule
    @jsondata:Name {value: "use_custom"}
    boolean useCustom?;
    # The ID of this availability rule. 
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesSegmentsRecurrence segmentsRecurrence?;
    # The timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The owner of this availability rule. 
    string email?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
};

# The organizer of the schedule. This field is read-only
public type InlineResponse2011Organizer record {
    # This field indicates if this user is the organizer. This field is read-only
    boolean self?;
    # The organizer's display name
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The organizer's email address
    string email?;
};

public type SchedulerschedulesscheduleIdAvailabilityRules record {
    # This field indicates whether to use the custom availability instead of the rule
    @jsondata:Name {value: "use_custom"}
    boolean useCustom?;
    # The ID of this availability rule. 
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesscheduleIdSegmentsRecurrence segmentsRecurrence?;
    # The timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The owner of this availability rule. 
    string email?;
    # The available time segments of the event
    SchedulerschedulesscheduleIdSegments[] segments?;
};

# Represents the Queries record for the operation: insert_schedule
public type InsertScheduleQueries record {
    # This field indicates that the admin handles certain users. This setting is only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

# The date interval to override
public type ScheduleravailabilitySegments record {
    # This field indicates the start date to override
    string 'start;
    # This field indicates the end date to override
    string end;
};

public type InlineResponse2004TrackingParams record {
    # The scheduler tags that correspond to UTM parameters one by one
    string label?;
    # The value of UTM parameters set in schedule links by host
    string value?;
    # The UTM parameters in schedule links
    string 'key?;
};

public type InlineResponse2001Items record {
    # The owner's ID
    string owner?;
    boolean default?;
    string name?;
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    InlineResponse2001SegmentsRecurrence segmentsRecurrence?;
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
};

# The rules of this availability schedule
public type ScheduleravailabilitySegmentsRecurrence record {
    # Thursday
    ScheduleravailabilitySegmentsRecurrenceSun[] thu?;
    # Tuesday
    ScheduleravailabilitySegmentsRecurrenceSun[] tue?;
    # Wednesday
    ScheduleravailabilitySegmentsRecurrenceSun[] wed?;
    # Saturday
    ScheduleravailabilitySegmentsRecurrenceSun[] sat?;
    # Friday 
    ScheduleravailabilitySegmentsRecurrenceSun[] fri?;
    # Sundays
    ScheduleravailabilitySegmentsRecurrenceSun[] sun?;
    # Monday
    ScheduleravailabilitySegmentsRecurrenceSun[] mon?;
};

public type InlineResponse2003Attendees record {
    # This field indicates when the attendee attended this event
    string created?;
    # The ID of attendee
    @jsondata:Name {value: "attendee_id"}
    string attendeeId?;
    #  The attendee's last name
    @jsondata:Name {value: "last_name"}
    string lastName?;
    # The attendee's name
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The attendee's time zone
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # Whether to show events or not
    @jsondata:Name {value: "no_show"}
    boolean noShow?;
    # Whether the attendee is the booker
    boolean booker?;
    # The attendee's first name
    @jsondata:Name {value: "first_name"}
    string firstName?;
    # The attendee's email
    string email?;
};

public type InlineResponse2001SegmentsRecurrence record {
    # Thursday
    ScheduleravailabilitySegmentsRecurrenceSun[] thu?;
    # Tuesday
    ScheduleravailabilitySegmentsRecurrenceSun[] tue?;
    # Wednesday
    ScheduleravailabilitySegmentsRecurrenceSun[] wed?;
    # Saturday
    ScheduleravailabilitySegmentsRecurrenceSun[] sat?;
    # Friday 
    ScheduleravailabilitySegmentsRecurrenceSun[] fri?;
    # Sunday
    ScheduleravailabilitySegmentsRecurrenceSun[] sun?;
    # Monday
    ScheduleravailabilitySegmentsRecurrenceSun[] mon?;
};

# the stats of the previous period with a length of also N. Last N day is counting from today and backtrace N days. Previous period is counting from N days ago and back tracking another N days
public type InlineResponse200PreviousPeriod record {
    # The number of "all host available" type schedules
    @jsondata:Name {value: "all_host_available"}
    int allHostAvailable?;
    # The number of rescheduled scheduled events
    @jsondata:Name {value: "scheduled_events_rescheduled"}
    int scheduledEventsRescheduled?;
    # The number of completed scheduled events
    @jsondata:Name {value: "scheduled_events_completed"}
    int scheduledEventsCompleted?;
    # The number of cancelled schedules
    @jsondata:Name {value: "schedules_canceled"}
    int schedulesCanceled?;
    # The number of "one-off" type schedules
    @jsondata:Name {value: "one_off_meeting"}
    int oneOffMeeting?;
    # The number of "meeting poll" type schedules
    @jsondata:Name {value: "meeting_poll"}
    int meetingPoll?;
    # The number of "one to many" type schedules
    @jsondata:Name {value: "one_to_many"}
    int oneToMany?;
    # The number of "any host available" type schedules
    @jsondata:Name {value: "any_host_available"}
    int anyHostAvailable?;
    # The number of cancelled scheduled events
    @jsondata:Name {value: "scheduled_events_canceled"}
    int scheduledEventsCanceled?;
    # The number of "one to one" type schedules
    @jsondata:Name {value: "one_to_one"}
    int oneToOne?;
    # The number of created scheduled events
    @jsondata:Name {value: "scheduled_events_created"}
    int scheduledEventsCreated?;
    # The number of created schedules
    @jsondata:Name {value: "schedules_created"}
    int schedulesCreated?;
};

public type SchedulereventseventIdAttendees record {
    # The ID of attendee
    @jsondata:Name {value: "attendee_id"}
    string attendeeId?;
    # This field inidcates the attendee if shown in the scheduled event
    @jsondata:Name {value: "no_show"}
    boolean noShow?;
    # The attendee's email
    string email?;
};

# The week of the available time rule
public type SchedulerschedulesSegmentsRecurrence record {
    # Thursday
    ScheduleravailabilitySegmentsRecurrenceSun[] thu?;
    # Tuesday
    ScheduleravailabilitySegmentsRecurrenceSun[] tue?;
    # Wednesday
    ScheduleravailabilitySegmentsRecurrenceSun[] wed?;
    # Saturday
    ScheduleravailabilitySegmentsRecurrenceSun[] sat?;
    # Friday 
    ScheduleravailabilitySegmentsRecurrenceSun[] fri?;
    # Sundays
    ScheduleravailabilitySegmentsRecurrenceSun[] sun?;
    # Monday
    ScheduleravailabilitySegmentsRecurrenceSun[] mon?;
};

public type SchedulerSchedulesBody record {
    # The method of the type of `addOn`, such as Zoom meeting, Zoom phone, or offline
    @jsondata:Name {value: "add_on_type"}
    "zoomMeeting"|"zoomPhone"|"offline" addOnType?;
    # The schedule's end date
    @jsondata:Name {value: "end_date"}
    string endDate?;
    # This field sets the frequency of available time slots for invitees
    @jsondata:Name {value: "start_time_increment"}
    decimal startTimeIncrement?;
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # This field indicates if the schedule type is "one" (belongs to an individual user) or "multiple"
    @jsondata:Name {value: "schedule_type"}
    "one"|"multiple" scheduleType?;
    # The hexadecimal color value of the event type's scheduling page
    string color?;
    # This field contains the custom question
    @jsondata:Name {value: "custom_fields"}
    SchedulerschedulesCustomFields[] customFields?;
    # The schedule's description
    @constraint:String {maxLength: 8192}
    string description?;
    # This field indicates if the schedule is active
    boolean active?;
    # This field sets the maximum events allowed per day
    @jsondata:Name {value: "booking_limit"}
    decimal bookingLimit?;
    # This field indicates if the event type is hidden on the owner's main scheduling page
    boolean secret?;
    # The timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The availability of the time rule
    @jsondata:Name {value: "availability_rules"}
    SchedulerschedulesAvailabilityRules[] availabilityRules;
    # This field indicates the maximum invitees per event
    @constraint:Number {minValue: 1, maxValue: 200}
    decimal capacity;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
    # This field indicates the duration of the meeting in minutes, range: [1, 1440]
    @constraint:Number {minValue: 15, maxValue: 1440}
    decimal duration?;
    # This field indicates the minimum time before a schedule starts when the attendees can book
    @constraint:Number {minValue: 0, maxValue: 14340}
    decimal cushion?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # This field indicates the extra time before or after the booked schedule
    SchedulerschedulesBuffer buffer?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesSegmentsRecurrence segmentsRecurrence?;
    # The schedule time range. Unlimited means forever and fixed means using `startDate` and `endDate`
    @jsondata:Name {value: "interval_type"}
    "unlimited"|"fixed" intervalType?;
    # The event portion of the event's URL that identifies a specific web page
    @constraint:String {maxLength: 256, minLength: 3}
    string slug?;
    # This field indicates the use of the availability rule
    @jsondata:Name {value: "availability_override"}
    boolean availabilityOverride;
    # The schedule's start date
    @jsondata:Name {value: "start_date"}
    string startDate?;
};

# Represents the Queries record for the operation: patch_scheduled_events
public type PatchScheduledEventsQueries record {
    # This field indicates whether the admin handles certain users. It's only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

public type InlineResponse2003TrackingParams record {
    # The scheduler tags that correspond to UTM parameters one by one
    string label?;
    # The value of UTM parameters set in schedule links by host
    string value?;
    # The UTM parameters in the schedule links
    string 'key?;
};

# This field indicates the extra time before or after the booked schedule
public type SchedulerschedulesBuffer record {
    # This field adds the time after the booked schedule
    @constraint:Number {minValue: 0, maxValue: 240}
    decimal before?;
    # This field adds the time before the booked schedule
    @constraint:Number {minValue: 0, maxValue: 240}
    decimal after?;
};

# The extra time before or after booked schedule
public type SchedulerschedulesscheduleIdBuffer record {
    # This field adds time after the booked schedule
    @constraint:Number {minValue: 0, maxValue: 240}
    decimal before?;
    # This field adds time before the booked schedule
    @constraint:Number {minValue: 0, maxValue: 240}
    decimal after?;
};

public type SchedulerschedulesscheduleIdSegments record {
    # The start date-time of the segment
    string 'start?;
    # The end date-time of the segment
    string end?;
};

# The availability schedule set by the user
public type InlineResponse201 record {
    # An URI reference to a user
    string owner?;
    # The default availability schedule in use
    boolean default?;
    # The name of this availability schedule
    string name?;
    # The unique ID of the availability
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    ScheduleravailabilitySegmentsRecurrence segmentsRecurrence?;
    # The timezone for which this availability schedule originates
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The date on which the rule needs to be applied outside of the availability rule
    record {}[] segments?;
};

public type InlineResponse2004Attendees record {
    # This field indicates when the attendee attended this event
    string created?;
    # The ID of attendee
    @jsondata:Name {value: "attendee_id"}
    string attendeeId?;
    #  The attendee's last name
    @jsondata:Name {value: "last_name"}
    string lastName?;
    # The attendee's name
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The attendee's time zone
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # Whether or not to show the event
    @jsondata:Name {value: "no_show"}
    boolean noShow?;
    # Whether the attendee is the booker
    boolean booker?;
    # The attendee's first name
    @jsondata:Name {value: "first_name"}
    string firstName?;
    # The attendee's email
    string email?;
};

public type InlineResponse200 record {
    # The most popular schedules in the given time range
    @jsondata:Name {value: "popular_schedules"}
    record {}[] popularSchedules?;
    # The users with the least scheduled events
    @jsondata:Name {value: "users_with_least_events"}
    record {}[] usersWithLeastEvents?;
    @jsondata:Name {value: "last_n_days"}
    InlineResponse200LastNDays lastNDays?;
    # The distribution of number of events scheduled in a day
    @jsondata:Name {value: "popular_time_of_day"}
    record {}[] popularTimeOfDay?;
    @jsondata:Name {value: "previous_period"}
    InlineResponse200PreviousPeriod previousPeriod?;
    # The event distribution by duration
    @jsondata:Name {value: "event_distribution_by_duration"}
    record {}[] eventDistributionByDuration?;
    # The distribution of number of events scheduled in a week
    @jsondata:Name {value: "popular_time_of_week"}
    record {}[] popularTimeOfWeek?;
    # The users with the most scheduled events
    @jsondata:Name {value: "users_with_most_events"}
    record {}[] usersWithMostEvents?;
};

# The week of available time rule
public type SchedulerschedulesscheduleIdSegmentsRecurrence record {
    # Thursday
    ScheduleravailabilitySegmentsRecurrenceSun[] thu?;
    # Tuesday
    ScheduleravailabilitySegmentsRecurrenceSun[] tue?;
    # Wednesday
    ScheduleravailabilitySegmentsRecurrenceSun[] wed?;
    # Saturday
    ScheduleravailabilitySegmentsRecurrenceSun[] sat?;
    # Friday 
    ScheduleravailabilitySegmentsRecurrenceSun[] fri?;
    # Sunday
    ScheduleravailabilitySegmentsRecurrenceSun[] sun?;
    # Monday
    ScheduleravailabilitySegmentsRecurrenceSun[] mon?;
};

# Represents the Queries record for the operation: delete_schedules
public type DeleteSchedulesQueries record {
    # This field indicates that the admin handles certain users. This setting is only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

# Represents the Queries record for the operation: delete_scheduled_events
public type DeleteScheduledEventsQueries record {
    # This field indicates whether the admin handles certain users. It's only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

# Represents the Queries record for the operation: patch_schedule
public type PatchScheduleQueries record {
    # This field indicates that the admin handles certain users. This setting is only for admin
    @http:Query {name: "user_id"}
    string userId?;
};

# Represents the Queries record for the operation: list_availability
public type ListAvailabilityQueries record {
    # The token that specifies which result page to return
    @http:Query {name: "next_page_token"}
    string nextPageToken?;
    # The return of the specific user's availability
    @http:Query {name: "user_id"}
    string userId?;
    # The maximum number of availability returned on one result page
    @http:Query {name: "page_size"}
    int pageSize?;
};

# The portions of the event resource
public type EventseventIdBody record {
    SchedulereventseventIdAttendees[] attendees?;
    # The meeting notes of the event
    @jsondata:Name {value: "meeting_notes"}
    string meetingNotes?;
    # The status of event: confirmed or cancelled
    "confirmed"|"cancelled" status?;
};

# The availability schedule set by the user
public type AvailabilityavailabilityIdBody record {
    # The default availability schedule in use
    boolean default?;
    # The name of this availability schedule
    @constraint:String {minLength: 1}
    string name;
    @jsondata:Name {value: "segments_recurrence"}
    ScheduleravailabilitySegmentsRecurrence segmentsRecurrence?;
    # The timezone for which this availability schedule originates
    @jsondata:Name {value: "time_zone"}
    string timeZone;
    # The date on which the rule needs to be applied outside of the availability rule
    ScheduleravailabilityavailabilityIdSegments[] segments?;
};

# The week of the available time rule
public type SchedulerschedulesscheduleIdSegmentsRecurrence1 record {
    # Thursday
    ScheduleravailabilitySegmentsRecurrenceSun[] thu?;
    # Tuesday
    ScheduleravailabilitySegmentsRecurrenceSun[] tue?;
    # Wednesday
    ScheduleravailabilitySegmentsRecurrenceSun[] wed?;
    # Saturday
    ScheduleravailabilitySegmentsRecurrenceSun[] sat?;
    # Friday 
    ScheduleravailabilitySegmentsRecurrenceSun[] fri?;
    # Sunday
    ScheduleravailabilitySegmentsRecurrenceSun[] sun?;
    # Monday
    ScheduleravailabilitySegmentsRecurrenceSun[] mon?;
};

# The creator of the schedule. This field is read-only
public type InlineResponse2005Creator record {
    # This field indicates if you created the schedule. The field is read-only
    boolean self?;
    # This field indicates the creator of the display name
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # This field indicates the creator's email address
    string email?;
};

# Represents the Queries record for the operation: list_schedules
public type ListSchedulesQueries record {
    # Whether to include the deleted schedule (with status equals "cancelled") in the result
    @http:Query {name: "show_deleted"}
    boolean showDeleted?;
    # The token that specifies which result page to return
    @http:Query {name: "next_page_token"}
    string nextPageToken?;
    # The return of the specific user's schedules. Ths setting is only for admin
    @http:Query {name: "user_id"}
    string userId?;
    # The lower bound (exclusive) for a schedule's end time from which to filter
    string 'from?;
    # The upper bound (exclusive) for a schedule's start time from which to filter
    string to?;
    # The time zone in the response
    @http:Query {name: "time_zone"}
    string timeZone?;
    # The maximum number of schedule results returned on a result page
    @http:Query {name: "page_size"}
    int pageSize?;
};

public type InlineResponse2012 record {
    # The scheduling link URL
    @jsondata:Name {value: "scheduling_url"}
    string schedulingUrl;
};

public type InlineResponse2011 record {
    # The schedule's end date
    @jsondata:Name {value: "end_date"}
    string endDate?;
    # The hexadecimal color value of the event type's scheduling page
    string color?;
    # The schedule's description
    @constraint:String {maxLength: 8192}
    string description?;
    # This field indicates if the event type is hidden on the owner's main scheduling page
    boolean secret?;
    # The availability of the time rule
    @jsondata:Name {value: "availability_rules"}
    InlineResponse2011AvailabilityRules[] availabilityRules?;
    # This field indicates the maximum invitees per event
    @constraint:Number {minValue: 1, maxValue: 200}
    decimal capacity?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
    # This field indicates the duration of the meeting in minutes, range: [1, 1440]
    @constraint:Number {minValue: 15, maxValue: 1440}
    decimal duration?;
    # This field indicates the minimum time before a schedule starts when the attendees can book
    @constraint:Number {minValue: 0, maxValue: 14340}
    decimal cushion?;
    # This field indicates the extra time before or after the booked schedule
    SchedulerschedulesBuffer buffer?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesSegmentsRecurrence segmentsRecurrence?;
    # The event portion of the event's URL that identifies a specific web page
    @constraint:String {maxLength: 256, minLength: 3}
    string slug?;
    # The schedule time range. Unlimited means forever and fixed means using `startDate` and `endDate`
    @jsondata:Name {value: "interval_type"}
    "unlimited"|"fixed" intervalType?;
    # The schedule's start date
    @jsondata:Name {value: "start_date"}
    string startDate?;
    # The method of the type of `addOn`, such as Zoom meeting, Zoom phone, or offline
    @jsondata:Name {value: "add_on_type"}
    "zoomMeeting"|"zoomPhone"|"offline" addOnType?;
    # The URL of the user’s scheduling site where invitees book this event type
    @jsondata:Name {value: "scheduling_url"}
    string schedulingUrl?;
    # This field sets the frequency of available time slots for invitees
    @jsondata:Name {value: "start_time_increment"}
    decimal startTimeIncrement?;
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # The creator of the schedule. The field is read-only
    InlineResponse2011Creator creator?;
    # This field indicates if the schedule type is "one" (belongs to an individual user) or "multiple"
    @jsondata:Name {value: "schedule_type"}
    "one"|"multiple" scheduleType?;
    # This field contains the custom question
    @jsondata:Name {value: "custom_fields"}
    InlineResponse2011CustomFields[] customFields?;
    # This field indicates if the schedule is active
    boolean active?;
    # This field sets the maximum events allowed per day
    @jsondata:Name {value: "booking_limit"}
    decimal bookingLimit?;
    # the timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The organizer of the schedule. This field is read-only
    InlineResponse2011Organizer organizer?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # The unique identifier of schedule
    @jsondata:Name {value: "schedule_id"}
    string scheduleId?;
    # The moment the schedule type was updated
    string updated?;
    # This field indicates the use of the availability rule
    @jsondata:Name {value: "availability_override"}
    boolean availabilityOverride?;
    # The status of schedule: confirmed or cancelled
    "confirmed"|"cancelled" status?;
};

# OAuth2 Refresh Token Grant Configs
public type OAuth2RefreshTokenGrantConfig record {|
    *http:OAuth2RefreshTokenGrantConfig;
    # Refresh URL
    string refreshUrl = "";
|};

public type SchedulerschedulesAvailabilityRules record {
    # This field indicates the use of custom availability instead of the rule
    @jsondata:Name {value: "use_custom"}
    boolean useCustom?;
    # The ID of this availability rule. 
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesSegmentsRecurrence segmentsRecurrence?;
    # the timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The owner of this availability rule. 
    string email?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
};

public type ScheduleravailabilitySegmentsRecurrenceSun record {
    # The start time of this day
    string 'start?;
    # The end time of this day
    string end?;
};

# The stats of the last N days
public type InlineResponse200LastNDays record {
    # The number of "all host available" type schedules
    @jsondata:Name {value: "all_host_available"}
    int allHostAvailable?;
    # The number of rescheduled scheduled events
    @jsondata:Name {value: "scheduled_events_rescheduled"}
    int scheduledEventsRescheduled?;
    # The number of completed scheduled events
    @jsondata:Name {value: "scheduled_events_completed"}
    int scheduledEventsCompleted?;
    # The number of cancelled schedules
    @jsondata:Name {value: "schedules_canceled"}
    int schedulesCanceled?;
    # The number of "one-off" type schedules
    @jsondata:Name {value: "one_off_meeting"}
    int oneOffMeeting?;
    # The number of "meeting poll" type schedules
    @jsondata:Name {value: "meeting_poll"}
    int meetingPoll?;
    # The number of "one to many" type schedules
    @jsondata:Name {value: "one_to_many"}
    int oneToMany?;
    # The number of "any host available" type schedules
    @jsondata:Name {value: "any_host_available"}
    int anyHostAvailable?;
    # The number of cancelled scheduled events
    @jsondata:Name {value: "scheduled_events_canceled"}
    int scheduledEventsCanceled?;
    # The number of "one to one" type schedules
    @jsondata:Name {value: "one_to_one"}
    int oneToOne?;
    # The number of created scheduled events
    @jsondata:Name {value: "scheduled_events_created"}
    int scheduledEventsCreated?;
    # The number of created schedules
    @jsondata:Name {value: "schedules_created"}
    int schedulesCreated?;
};

public type SchedulerschedulesscheduleIdCustomFields record {
    # The invitee's option(s) for single_select or multi_select type of responses
    @jsondata:Name {value: "answer_choices"}
    SchedulerschedulesscheduleIdCustomFieldsAnswerchoicesItemsString[] answerChoices?;
    # The type of response that the invitee provides to the custom question. It can be one or multiple lines of text, a phone number, or single- or multiple-select.[`string text phone_number single_select multi_select`]
    "text"|"string"|"phone_number"|"choices_one"|"choices_many"|"select" format;
    # The ID of this question
    @jsondata:Name {value: "custom_field_id"}
    string customFieldId?;
    # The custom question that the host created for the event type
    string name;
    # If the custom question lets invitees record a written response, in addition to single-select or multiple-select type of responses, then it's true. Otherwise, it's false
    @jsondata:Name {value: "include_other"}
    boolean includeOther;
    # The position of this question
    decimal position;
    # If the question created by the host is turned ON and visible on the event booking page, then it's true. If it's turned OFF and invisible on the event booking page, then it's false
    boolean enabled;
    # If a response to the question, created by the host, is required for invitees to book the event type, then it's true. If it's not required, it's false
    boolean required;
};

public type SchedulerschedulesSegments record {
    # The start date and time of the segment
    string 'start?;
    # The end date and time of the segment
    string end?;
};

# The date interval that needs to overridden
public type ScheduleravailabilityavailabilityIdSegments record {
    # The start date to override
    string 'start;
    # The end date to override
    string end;
};

# Represents the Queries record for the operation: report_analytics
public type ReportAnalyticsQueries record {
    # The specific user's web user ID. Default is "me". Use "all" to query for analytics with respect to all members under that account. 
    @http:Query {name: "user_id"}
    string userId?;
    # The lower bound (exclusive) for an event's end time from which to filter. Optional. The default is not to filter by end time. It must be an RFC3339 timestamp with mandatory time zone offset, for example, 2011-06-03T10:00:00-07:00, 2011-06-03T10:00:00Z. Milliseconds can be provided but are ignored. If `timeMax` is set, `timeMin` must be smaller than `timeMax`
    string 'from?;
    # The upper bound (exclusive) for an event's start time to filter by. Optional. The default is not to filter by start time. It must be an RFC3339 timestamp with mandatory time zone offset. For example, 2011-06-03T10:00:00-07:00, 2011-06-03T10:00:00Z. Milliseconds may be provided but are ignored. If `timeMin` is set, `timeMax` must be greater than `timeMin`
    string to?;
    # The time zone in the response. The default is the time zone of the calendar. Optional. 
    @http:Query {name: "time_zone"}
    string timeZone?;
};

public type SchedulerschedulesscheduleIdCustomFieldsAnswerchoicesItemsString string;

# The availability of the schedule query result of given user
public type InlineResponse2001 record {
    #  The token for a later to retrieve only the entries that have changed since this result was returned. It's omitted if further results are available, in which case `nextPageToken` is provided
    @jsondata:Name {value: "next_page_token"}
    string nextPageToken?;
    # array[User Availability Schedule]
    InlineResponse2001Items[] items?;
};

public type InlineResponse2003 record {
    # The token to access the next page of this result
    @jsondata:Name {value: "next_page_token"}
    string nextPageToken?;
    InlineResponse2003Items[] items?;
};

public type SchedulerschedulesCustomFieldsAnswerchoicesItemsString string;

# The availability schedule set by the user
public type InlineResponse2002 record {
    # The owner's ID
    string owner?;
    # The default availability schedule in use
    boolean default?;
    # The name of this availability schedule
    string name?;
    # The unique ID of availability
    @jsondata:Name {value: "availability_id"}
    string availabilityId?;
    @jsondata:Name {value: "segments_recurrence"}
    ScheduleravailabilitySegmentsRecurrence segmentsRecurrence?;
    # The timezone for which this availability schedule originates
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
};

public type InlineResponse2005 record {
    # The token that accesses the next page of this result
    @jsondata:Name {value: "next_page_token"}
    string nextPageToken?;
    InlineResponse2005Items[] items?;
};

public type InlineResponse2004 record {
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # The attendees of the event
    InlineResponse2004Attendees[] attendees?;
    # The meeting notes of the event
    @jsondata:Name {value: "meeting_notes"}
    string meetingNotes?;
    # The event's description
    @constraint:String {maxLength: 8192}
    string description?;
    # The scheduled event's end date time
    @jsondata:Name {value: "end_date_time"}
    string endDateTime?;
    # The unique identifier of event
    @jsondata:Name {value: "event_id"}
    string eventId?;
    # This field indicates whether the type is default(scheduled) or a pending event
    @jsondata:Name {value: "event_type"}
    "default"|"pending" eventType?;
    # The information to track the source of invitee. Only use this setting you add UTM parameters in schedule links
    @jsondata:Name {value: "tracking_params"}
    InlineResponse2004TrackingParams[] trackingParams?;
    # The guest's collection
    string[] guests?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # The scheduled event's start date time
    @jsondata:Name {value: "start_date_time"}
    string startDateTime?;
    # The unique identifier of schedule
    @jsondata:Name {value: "schedule_id"}
    string scheduleId?;
    # The moment the event was updated
    string updated?;
    # The meeting details for when users have scheduled appointments
    @jsondata:Name {value: "external_location"}
    record {string kind?; string meeting_id?; string personal_meeting_id?; string meeting_passcode?; string meeting_description?; string meeting_join_url?;} externalLocation?;
    # The status of event: confirmed or cancelled
    "confirmed"|"cancelled" status?;
};

public type InlineResponse2005Items record {
    # The schedule's end date
    @jsondata:Name {value: "end_date"}
    string endDate?;
    # The hexadecimal color value of the event type's scheduling page
    string color?;
    # The schedule's description
    @constraint:String {maxLength: 8192}
    string description?;
    # This field indicates if the event type is hidden on the owner's main scheduling page
    boolean secret?;
    # The availability of the time rule
    @jsondata:Name {value: "availability_rules"}
    InlineResponse2005AvailabilityRules[] availabilityRules?;
    # This field indicates the maximum invitees per event
    @constraint:Number {minValue: 1, maxValue: 200}
    decimal capacity?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
    # This field indicates the duration of the meeting in minutes, range: [1, 1440]
    @constraint:Number {minValue: 15, maxValue: 1440}
    decimal duration?;
    # This field indicates the minimum time before a schedule starts when the attendees can book
    @constraint:Number {minValue: 0, maxValue: 14340}
    decimal cushion?;
    # This field indicates the extra time before or after the booked schedule
    SchedulerschedulesBuffer buffer?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesscheduleIdSegmentsRecurrence1 segmentsRecurrence?;
    # The event portion of the event's URL that identifies a specific web page
    @constraint:String {maxLength: 256, minLength: 3}
    string slug?;
    # The schedule time range. Unlimited means forever and fixed means using `startDate` and `endDate`
    @jsondata:Name {value: "interval_type"}
    "unlimited"|"fixed" intervalType?;
    # The schedule's start date
    @jsondata:Name {value: "start_date"}
    string startDate?;
    # The method of the type of `addOn`, such as Zoom meeting, Zoom phone, or offline
    @jsondata:Name {value: "add_on_type"}
    "zoomMeeting"|"zoomPhone"|"offline" addOnType?;
    # The URL of the user's scheduling site where invitees book this event type
    @jsondata:Name {value: "scheduling_url"}
    string schedulingUrl?;
    # This field sets the frequency of available time slots for invitees
    @jsondata:Name {value: "start_time_increment"}
    decimal startTimeIncrement?;
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # The creator of the schedule. This field is read-only
    InlineResponse2005Creator creator?;
    # This field indicates if the schedule type is "one" (belongs to an individual user) or "multiple"
    @jsondata:Name {value: "schedule_type"}
    "one"|"multiple" scheduleType?;
    # This field contains the custom question
    @jsondata:Name {value: "custom_fields"}
    InlineResponse2011CustomFields[] customFields?;
    # This field indicates if the schedule is active
    boolean active?;
    # This field sets the maximum events allowed per day
    @jsondata:Name {value: "booking_limit"}
    decimal bookingLimit?;
    # the timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The organizer of the schedule. This field is read-only
    InlineResponse2011Organizer organizer?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # The unique identifier of the schedule
    @jsondata:Name {value: "schedule_id"}
    string scheduleId?;
    # The moment the schedule type was updated
    string updated?;
    # This field indicates the use of the availability rule
    @jsondata:Name {value: "availability_override"}
    boolean availabilityOverride?;
    # The status of schedule: confirmed or cancelled
    "confirmed"|"cancelled" status?;
};

# The user's information
public type InlineResponse2007 record {
    # The URL of the user’s scheduling site where invitees book this event type
    @jsondata:Name {value: "scheduling_url"}
    string schedulingUrl?;
    # This field enables users to upload their company's logo on Zoom
    string logo?;
    # The user's name
    @jsondata:Name {value: "display_name"}
    string displayName?;
    # The time zone to use when presenting time to the user
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The portion of URL for the user's scheduling page where invitees book sessions that renders in a human-readable format
    string slug?;
    # This field enables users to upload their personal avatars on Zoom
    string picture?;
};

# Represents the Queries record for the operation: list_scheduled_events
public type ListScheduledEventsQueries record {
    # Whether to include deleted events (with status equals `cancelled`) in the result
    @http:Query {name: "show_deleted"}
    boolean showDeleted?;
    # This field returns search results from meeting ID or summary
    string search?;
    # Whether to return the pending events
    @http:Query {name: "event_type"}
    "pending" eventType?;
    # The token that specifies which result page to return
    @http:Query {name: "next_page_token"}
    string nextPageToken?;
    # The return of the specific user's scheduled event. It's only for admin
    @http:Query {name: "user_id"}
    string userId?;
    # This field indicates the start time or the time when the event has been updated
    @http:Query {name: "order_by"}
    string orderBy?;
    # The lower bound (exclusive) for an event's end time from which to filter. 
    string 'from?;
    # The upper bound (exclusive) for an event's start time from which to filter
    string to?;
    # The time zone in the response
    @http:Query {name: "time_zone"}
    string timeZone?;
    # The maximum number of events returned on one result page
    @http:Query {name: "page_size"}
    int pageSize?;
};

public type InlineResponse2006 record {
    # The schedule's end date
    @jsondata:Name {value: "end_date"}
    string endDate?;
    # The hexadecimal color value of the event type's scheduling page
    string color?;
    # The schedule's description
    @constraint:String {maxLength: 8192}
    string description?;
    # This field indicates if the event type is hidden on the owner's main scheduling page
    boolean secret?;
    # The availability of the time rule
    @jsondata:Name {value: "availability_rules"}
    InlineResponse2006AvailabilityRules[] availabilityRules?;
    # This field indicates the maximum invitees per event
    @constraint:Number {minValue: 1, maxValue: 200}
    decimal capacity?;
    # The available time segments of the event
    SchedulerschedulesSegments[] segments?;
    # This field indicates the duration of the meeting in minutes, range: [1, 1440]
    @constraint:Number {minValue: 15, maxValue: 1440}
    decimal duration?;
    # This field indicates the minimum time before a schedule starts when the attendees can book
    @constraint:Number {minValue: 0, maxValue: 14340}
    decimal cushion?;
    # This field indicates the extra time before or after the booked schedule
    SchedulerschedulesBuffer buffer?;
    @jsondata:Name {value: "segments_recurrence"}
    SchedulerschedulesSegmentsRecurrence segmentsRecurrence?;
    # The event portion of the event's URL that identifies a specific web page
    @constraint:String {maxLength: 256, minLength: 3}
    string slug?;
    # The schedule time range. Unlimited means forever and fixed means using `startDate` and `endDate`
    @jsondata:Name {value: "interval_type"}
    "unlimited"|"fixed" intervalType?;
    # The schedule's start date
    @jsondata:Name {value: "start_date"}
    string startDate?;
    # The method of the type of `addOn`, such as Zoom meeting, Zoom phone, or offline
    @jsondata:Name {value: "add_on_type"}
    "zoomMeeting"|"zoomPhone"|"offline" addOnType?;
    # The URL of the user's scheduling site where invitees book this event type
    @jsondata:Name {value: "scheduling_url"}
    string schedulingUrl?;
    # This field sets the frequency of available time slots for invitees
    @jsondata:Name {value: "start_time_increment"}
    decimal startTimeIncrement?;
    # The event's summary
    @constraint:String {maxLength: 256}
    string summary?;
    # The creator of the schedule. The field is read-only
    InlineResponse2011Creator creator?;
    # This field indicates if the schedule type is **one** (belongs to an individual user) or **multiple**
    @jsondata:Name {value: "schedule_type"}
    "one"|"multiple" scheduleType?;
    # This field contains the custom question
    @jsondata:Name {value: "custom_fields"}
    InlineResponse2011CustomFields[] customFields?;
    # This field indicates if the schedule is active
    boolean active?;
    # This field sets the maximum events allowed per day
    @jsondata:Name {value: "booking_limit"}
    decimal bookingLimit?;
    # the timezone of this availability rule. 
    @jsondata:Name {value: "time_zone"}
    string timeZone?;
    # The organizer of the schedule. This field is read-only
    InlineResponse2011Organizer organizer?;
    # The information for a custom location
    @constraint:String {maxLength: 1024}
    string location?;
    # The unique identifier of a schedule
    @jsondata:Name {value: "schedule_id"}
    string scheduleId?;
    # The moment the schedule type was updated
    string updated?;
    # This field indicates the use of the availability rule
    @jsondata:Name {value: "availability_override"}
    boolean availabilityOverride?;
    # The status of schedule: confirmed or cancelled
    "confirmed"|"cancelled" status?;
};
