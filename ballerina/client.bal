// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;

# The Scheduler APIs let you programmatically interact with [Zoom Scheduler](https://developers.zoom.us/docs/zoom-scheduler/) features. They allow you to schedule, manage, and retrieve details about meetings, webinars, and other events on the Zoom platform. With powerful tools for integration, these APIs streamline event management and automate workflows in external applications.
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig? apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.zoom.us/v2") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        if config.auth is ApiKeysConfig {
            self.apiKeyConfig = (<ApiKeysConfig>config.auth).cloneReadOnly();
        } else {
            httpClientConfig.auth = <http:BearerTokenConfig|http:OAuth2RefreshTokenGrantConfig>config.auth;
            self.apiKeyConfig = ();
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }

    # Delete availability
    #
    # + availabilityId - The UUID of the availability schedule.
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns an empty response body. 
    resource isolated function delete scheduler/availability/[string availabilityId](map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/scheduler/availability/${getEncodedUri(availabilityId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Delete scheduled events 
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns an empty response body. 
    resource isolated function delete scheduler/events/[string eventId](map<string|string[]> headers = {}, *DeleteScheduledEventsQueries queries) returns http:Response|error {
        string resourcePath = string `/scheduler/events/${getEncodedUri(eventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Delete schedules
    #
    # + scheduleId - The unique identifier of the schedule.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns an empty response body. 
    resource isolated function delete scheduler/schedules/[string scheduleId](map<string|string[]> headers = {}, *DeleteSchedulesQueries queries) returns http:Response|error {
        string resourcePath = string `/scheduler/schedules/${getEncodedUri(scheduleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Report analytics
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns the scheduler analytics or the user ID or account ID provided. 
    resource isolated function get scheduler/analytics(map<string|string[]> headers = {}, *ReportAnalyticsQueries queries) returns InlineResponse200|error {
        string resourcePath = string `/scheduler/analytics`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List availability
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful availability of the schedule query result of given user. 
    resource isolated function get scheduler/availability(map<string|string[]> headers = {}, *ListAvailabilityQueries queries) returns InlineResponse2001|error {
        string resourcePath = string `/scheduler/availability`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get availability 
    #
    # + availabilityId - The UUID of the availability schedule.
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns an availability resource in the response body. 
    resource isolated function get scheduler/availability/[string availabilityId](map<string|string[]> headers = {}) returns InlineResponse2002|error {
        string resourcePath = string `/scheduler/availability/${getEncodedUri(availabilityId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List scheduled events
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns a response body with the following structure: 
    resource isolated function get scheduler/events(map<string|string[]> headers = {}, *ListScheduledEventsQueries queries) returns InlineResponse2003|error {
        string resourcePath = string `/scheduler/events`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get scheduled events 
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns the scheduled event resource in the response body. 
    resource isolated function get scheduler/events/[string eventId](map<string|string[]> headers = {}, *GetScheduledEventsQueries queries) returns InlineResponse2004|error {
        string resourcePath = string `/scheduler/events/${getEncodedUri(eventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List schedules
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns a response body with this structure. 
    resource isolated function get scheduler/schedules(map<string|string[]> headers = {}, *ListSchedulesQueries queries) returns InlineResponse2005|error {
        string resourcePath = string `/scheduler/schedules`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get schedules
    #
    # + scheduleId - The schedule's unique identifier.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns an schedule resource in the response body. 
    resource isolated function get scheduler/schedules/[string scheduleId](map<string|string[]> headers = {}, *GetScheduleQueries queries) returns InlineResponse2006|error {
        string resourcePath = string `/scheduler/schedules/${getEncodedUri(scheduleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get user
    #
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns user information in the response body. 
    resource isolated function get scheduler/users/[string userId](map<string|string[]> headers = {}) returns InlineResponse2007|error {
        string resourcePath = string `/scheduler/users/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Patch availability
    #
    # + availabilityId - The UUID of the availability schedule.
    # + headers - Headers to be sent with the request 
    # + payload - In the request body, supply availability resource properties. 
    # + return - If successful, this method returns an empty response body. 
    resource isolated function patch scheduler/availability/[string availabilityId](AvailabilityavailabilityIdBody payload, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/scheduler/availability/${getEncodedUri(availabilityId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Patch scheduled events
    #
    # + eventId - The opaque identifier of the scheduled event.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - In the request body, it supplies the relevant portions of event resource. 
    # + return - If successful, this method returns an event resource in the response body. 
    resource isolated function patch scheduler/events/[string eventId](EventseventIdBody payload, map<string|string[]> headers = {}, *PatchScheduledEventsQueries queries) returns http:Response|error {
        string resourcePath = string `/scheduler/events/${getEncodedUri(eventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Patch schedules
    #
    # + scheduleId - The schedule's unique identifier.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - In the request body, it supplies the relevant portions of a schedule resource, according to the rules of patch semantics. 
    # + return - If successful, this method returns an empty response body. 
    resource isolated function patch scheduler/schedules/[string scheduleId](SchedulesscheduleIdBody payload, map<string|string[]> headers = {}, *PatchScheduleQueries queries) returns http:Response|error {
        string resourcePath = string `/scheduler/schedules/${getEncodedUri(scheduleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Insert availability
    #
    # + headers - Headers to be sent with the request 
    # + payload - In the request body, it supplies an availability resource properties. 
    # + return - If successful, this method returns a availability resource in the response body. 
    resource isolated function post scheduler/availability(SchedulerAvailabilityBody payload, map<string|string[]> headers = {}) returns InlineResponse201|error {
        string resourcePath = string `/scheduler/availability`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Insert schedules
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - In the request body, it supplies the schedule resource properties. 
    # + return - If successful, this method returns an schedule resource in the response body. 
    resource isolated function post scheduler/schedules(SchedulerSchedulesBody payload, map<string|string[]> headers = {}, *InsertScheduleQueries queries) returns InlineResponse2011|error {
        string resourcePath = string `/scheduler/schedules`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Single use link
    #
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns a scheduling link URL in the response body. 
    resource isolated function post scheduler/schedules/single_use_link(SchedulesSingleUseLinkBody payload, map<string|string[]> headers = {}) returns InlineResponse2012|error {
        string resourcePath = string `/scheduler/schedules/single_use_link`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.Authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }
}
