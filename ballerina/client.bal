// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;

# The Scheduler APIs let you programmatically interact with [Zoom Scheduler](https://developers.zoom.us/docs/zoom-scheduler/) features. They allow you to schedule, manage, and retrieve details about meetings, webinars, and other events on the Zoom platform. With powerful tools for integration, these APIs streamline event management and automate workflows in external applications.
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig? apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.zoom.us/v2/scheduler") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        if config.auth is ApiKeysConfig {
            self.apiKeyConfig = (<ApiKeysConfig>config.auth).cloneReadOnly();
        } else {
            httpClientConfig.auth = <http:BearerTokenConfig|http:OAuth2RefreshTokenGrantConfig>config.auth;
            self.apiKeyConfig = ();
        }
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Report analytics
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns the scheduler analytics or the user ID or account ID provided 
    resource isolated function get analytics(map<string|string[]> headers = {}, *ReportAnalyticsQueries queries) returns InlineResponse200|error {
        string resourcePath = string `/analytics`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List availability
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful availability of the schedule query result of given user 
    resource isolated function get availability(map<string|string[]> headers = {}, *ListAvailabilityQueries queries) returns InlineResponse2001|error {
        string resourcePath = string `/availability`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Insert availability
    #
    # + headers - Headers to be sent with the request 
    # + payload - In the request body, it supplies an availability resource properties 
    # + return - If successful, this method returns a availability resource in the response body 
    resource isolated function post availability(SchedulerAvailabilityBody payload, map<string|string[]> headers = {}) returns InlineResponse201|error {
        string resourcePath = string `/availability`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get availability 
    #
    # + availabilityId - The UUID of the availability schedule
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns an availability resource in the response body 
    resource isolated function get availability/[string availabilityId](map<string|string[]> headers = {}) returns InlineResponse2002|error {
        string resourcePath = string `/availability/${getEncodedUri(availabilityId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete availability
    #
    # + availabilityId - The UUID of the availability schedule
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns an empty response body 
    resource isolated function delete availability/[string availabilityId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/availability/${getEncodedUri(availabilityId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Patch availability
    #
    # + availabilityId - The UUID of the availability schedule
    # + headers - Headers to be sent with the request 
    # + payload - In the request body, supply availability resource properties 
    # + return - If successful, this method returns an empty response body 
    resource isolated function patch availability/[string availabilityId](AvailabilityavailabilityIdBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/availability/${getEncodedUri(availabilityId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # List scheduled events
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns a response body with the following structure: 
    resource isolated function get events(map<string|string[]> headers = {}, *ListScheduledEventsQueries queries) returns InlineResponse2003|error {
        string resourcePath = string `/events`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get scheduled events 
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns the scheduled event resource in the response body 
    resource isolated function get events/[string eventId](map<string|string[]> headers = {}, *GetScheduledEventsQueries queries) returns InlineResponse2004|error {
        string resourcePath = string `/events/${getEncodedUri(eventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete scheduled events 
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns an empty response body 
    resource isolated function delete events/[string eventId](map<string|string[]> headers = {}, *DeleteScheduledEventsQueries queries) returns error? {
        string resourcePath = string `/events/${getEncodedUri(eventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Patch scheduled events
    #
    # + eventId - The opaque identifier of the scheduled event
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - In the request body, it supplies the relevant portions of event resource 
    # + return - If successful, this method returns an event resource in the response body 
    resource isolated function patch events/[string eventId](EventseventIdBody payload, map<string|string[]> headers = {}, *PatchScheduledEventsQueries queries) returns error? {
        string resourcePath = string `/events/${getEncodedUri(eventId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # List schedules
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns a response body with this structure 
    resource isolated function get schedules(map<string|string[]> headers = {}, *ListSchedulesQueries queries) returns InlineResponse2005|error {
        string resourcePath = string `/schedules`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Insert schedules
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - In the request body, it supplies the schedule resource properties 
    # + return - If successful, this method returns an schedule resource in the response body 
    resource isolated function post schedules(SchedulerSchedulesBody payload, map<string|string[]> headers = {}, *InsertScheduleQueries queries) returns InlineResponse2011|error {
        string resourcePath = string `/schedules`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get schedules
    #
    # + scheduleId - The schedule's unique identifier
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns an schedule resource in the response body 
    resource isolated function get schedules/[string scheduleId](map<string|string[]> headers = {}, *GetScheduleQueries queries) returns InlineResponse2006|error {
        string resourcePath = string `/schedules/${getEncodedUri(scheduleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete schedules
    #
    # + scheduleId - The unique identifier of the schedule
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - If successful, this method returns an empty response body 
    resource isolated function delete schedules/[string scheduleId](map<string|string[]> headers = {}, *DeleteSchedulesQueries queries) returns error? {
        string resourcePath = string `/schedules/${getEncodedUri(scheduleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Patch schedules
    #
    # + scheduleId - The schedule's unique identifier
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - In the request body, it supplies the relevant portions of a schedule resource, according to the rules of patch semantics 
    # + return - If successful, this method returns an empty response body 
    resource isolated function patch schedules/[string scheduleId](SchedulesscheduleIdBody payload, map<string|string[]> headers = {}, *PatchScheduleQueries queries) returns error? {
        string resourcePath = string `/schedules/${getEncodedUri(scheduleId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Single use link
    #
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns a scheduling link URL in the response body 
    resource isolated function post schedules/single_use_link(SchedulesSingleUseLinkBody payload, map<string|string[]> headers = {}) returns InlineResponse2012|error {
        string resourcePath = string `/schedules/single_use_link`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get user
    #
    # + headers - Headers to be sent with the request 
    # + return - If successful, this method returns user information in the response body 
    resource isolated function get users/[string userId](map<string|string[]> headers = {}) returns InlineResponse2007|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["Authorization"] = self.apiKeyConfig?.authorization;
        }
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }
}
